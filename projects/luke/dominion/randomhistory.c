Kenny Lu
November 2, 2015
CS362

NOTE: To run the random tests, run 'make randomtestadventurer.out' and 'make randomtestcard.out'

This file will be a record of what has changed coverage-wise when my random tests were implemented
for two different cards in dominion.c (including one card as the adventurer).

Random Test for adventurerCard():
For adventuererCard(), I created a random test similar to the one demonstrated in lecture which
saved a post game state that was initialized normally with the adventurerCard function and a
pre game state that was never run trough the adventurerCard but was mimiced to be ran through
that function through hand code that replicated what would happen if it was.  These two cases
were compared in the end and if there are any bugs, then the comparison would return a testFail
value of 1.  This test case was ran 2000 times with different gamestates set up with a random
number generator given by the rngs.c file.  For the adventurer card, we knew that cards are 
drawn until 2 treasures are found.  This was replicated in my code by writing out a function
similar to the function already.  In the end, when the test is ran, we find bugs because the 
at least one of the random test (2000 times ran) has failed.

Bug found: Comparing our replication code that drove the pre gamestate, we find that the
drawntreasue variable is set in a while loop to run to less than or equal to 2.  As a result,
3 cards are drawn yieldling to a failure in the random test.  Changing this less than equals
comparator to just a less than, yields a passing random test case.

Lines executed:9.54% of 650
Branches executed:7.19% of 417
Taken at least once:6.47% of 417

Coverage Info: From our dominion.c.gcov file after running our random test for the adventurerCard(),
we can see that each statement is run 2001 times as it should.  This is as expected and represents
100% statement coverage.  This is identical to our unit test but is run many more times.  WE can see
that the while loop is run 83% of the time with the 17% representing when the drawn treasure is equal
to 2 as expected.  Only 1% does the deck need to be shuffled because it is empty.


------------------------------------------------------------------------------------------------

Random Test for villageCard():
For the villageCard, I used the same approach to creating a random test as mentioned above. I
first saved a post game state that was initialized and ran through the villageCard() function. 
This represents the game state that would trigger the effects of the actual function.  With the 
random game state generated by our random number generator provided by rngs.c, the same game state
is replicated as the pre and post game states.  We ran the pre game state through a series of
code that mimiced what was being produced by the postgame state after being fed through the
villageCard function.  Upon comparison, if these game states are identical to each other,
than no bugs were found during the 2000 random test runs.  If there is any random test that
fails, then the random test in general does not pass even though it's just one random test
that fails.  Upon running our random test, wecan see that the test case fails.

Bug found:  Comparing our replication code that drove the pre gamestate, we find that the
There is a redundant drawCard() call that leads to two cards being drawn instead of one.

Lines executed:9.85% of 650
Branches executed:5.76% of 417
Taken at least once:4.80% of 417

Coverage info:  From our dominion.c.gcov file after running our random test for the villagecard(),
we can see that each statement is run 2001 times as it should.  This is as expected and represents
100% statement coverage.  This is identical to our unit test but is run many more times.  The branch
coverage shows the same 100% coverage for the function which is expected because we are Comparing
every single branch when comparing the game states.

